{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Django pattern library \u00b6 A module for Django that helps you to build pattern libraries and follow the Atomic design methodology. Documentation \u00b6 Documentation is located in GitHub in docs/ . Objective \u00b6 At the moment, the main focus is to allow developers and designers use exactly the same Django templates in a design pattern library and in production code. There are a lot of alternative solutions for building pattern libraries already. Have a look at Pattern Lab and Astrum , for example. But at Torchbox we mainly use Python and Django and we find it hard to maintain layout on big projects in several places: in a project's pattern library and in actual production code. This is our attempt to solve this issue and reduce the amount of copy-pasted code. To learn more about how this package can be used, have a look at our Wagtail Space 2020 talk: Reusable UI components: A journey from React to Wagtail How to install \u00b6 In your Django settings, add pattern_library into your INSTALLED_APPS , and pattern_library.loader_tags into the TEMPLATES setting. For example: INSTALLED_APPS = [ # ... 'pattern_library' , # ... ] TEMPLATES = [ { 'BACKEND' : 'django.template.backends.django.DjangoTemplates' , 'DIRS' : [], 'APP_DIRS' : True , 'OPTIONS' : { 'context_processors' : [ 'django.template.context_processors.debug' , 'django.template.context_processors.request' , 'django.contrib.auth.context_processors.auth' , 'django.contrib.messages.context_processors.messages' , ], 'builtins' : [ 'pattern_library.loader_tags' ], }, }, ] Note that this module only supports the Django template backend out of the box. Set the PATTERN_LIBRARY_TEMPLATE_DIR setting to point to a template directory with your patterns: PATTERN_LIBRARY_TEMPLATE_DIR = os . path . join ( BASE_DIR , 'project_styleguide' , 'templates' ) Note that PATTERN_LIBRARY_TEMPLATE_DIR must be available for template loaders . Include pattern_library.urls into your urlpatterns . Here's an example urls.py : from django.apps import apps from django.conf.urls import url , include urlpatterns = [ # ... Your URLs ] if apps . is_installed ( 'pattern_library' ): urlpatterns += [ url ( r '^pattern-library/' , include ( 'pattern_library.urls' )), ] This package is not intended for production. It is highly recommended to only enable this package in testing environments for a restricted, trusted audience. One simple way to do this is to only expose its URLs if apps.is_installed('pattern_library') , as demonstrated above, and only have the app installed in environment-specific settings. Contributing \u00b6 See anything you like in here? Anything missing? We welcome all support, whether on bug reports, feature requests, code, design, reviews, tests, documentation, and more. Please have a look at our contribution guidelines . If you just want to set up the project on your own computer, the contribution guidelines also contain all of the setup commands. Credits \u00b6 View the full list of contributors . BSD licensed.","title":"Home"},{"location":"#django-pattern-library","text":"A module for Django that helps you to build pattern libraries and follow the Atomic design methodology.","title":"Django pattern library"},{"location":"#documentation","text":"Documentation is located in GitHub in docs/ .","title":"Documentation"},{"location":"#objective","text":"At the moment, the main focus is to allow developers and designers use exactly the same Django templates in a design pattern library and in production code. There are a lot of alternative solutions for building pattern libraries already. Have a look at Pattern Lab and Astrum , for example. But at Torchbox we mainly use Python and Django and we find it hard to maintain layout on big projects in several places: in a project's pattern library and in actual production code. This is our attempt to solve this issue and reduce the amount of copy-pasted code. To learn more about how this package can be used, have a look at our Wagtail Space 2020 talk: Reusable UI components: A journey from React to Wagtail","title":"Objective"},{"location":"#how-to-install","text":"In your Django settings, add pattern_library into your INSTALLED_APPS , and pattern_library.loader_tags into the TEMPLATES setting. For example: INSTALLED_APPS = [ # ... 'pattern_library' , # ... ] TEMPLATES = [ { 'BACKEND' : 'django.template.backends.django.DjangoTemplates' , 'DIRS' : [], 'APP_DIRS' : True , 'OPTIONS' : { 'context_processors' : [ 'django.template.context_processors.debug' , 'django.template.context_processors.request' , 'django.contrib.auth.context_processors.auth' , 'django.contrib.messages.context_processors.messages' , ], 'builtins' : [ 'pattern_library.loader_tags' ], }, }, ] Note that this module only supports the Django template backend out of the box. Set the PATTERN_LIBRARY_TEMPLATE_DIR setting to point to a template directory with your patterns: PATTERN_LIBRARY_TEMPLATE_DIR = os . path . join ( BASE_DIR , 'project_styleguide' , 'templates' ) Note that PATTERN_LIBRARY_TEMPLATE_DIR must be available for template loaders . Include pattern_library.urls into your urlpatterns . Here's an example urls.py : from django.apps import apps from django.conf.urls import url , include urlpatterns = [ # ... Your URLs ] if apps . is_installed ( 'pattern_library' ): urlpatterns += [ url ( r '^pattern-library/' , include ( 'pattern_library.urls' )), ] This package is not intended for production. It is highly recommended to only enable this package in testing environments for a restricted, trusted audience. One simple way to do this is to only expose its URLs if apps.is_installed('pattern_library') , as demonstrated above, and only have the app installed in environment-specific settings.","title":"How to install"},{"location":"#contributing","text":"See anything you like in here? Anything missing? We welcome all support, whether on bug reports, feature requests, code, design, reviews, tests, documentation, and more. Please have a look at our contribution guidelines . If you just want to set up the project on your own computer, the contribution guidelines also contain all of the setup commands.","title":"Contributing"},{"location":"#credits","text":"View the full list of contributors . BSD licensed.","title":"Credits"},{"location":"overview/","text":"Overview \u00b6 The main idea of this package is to allow you use template in both: your pattern library and production code of your Django project. To achieve this the package must to provide a way to: Define a fake context for templates Override template tags (default and custom ones) Directory structure \u00b6 The initial structure of your pattern library should look like this: . \u251c\u2500\u2500 templates | \u2514\u2500\u2500 patterns | |\u2500\u2500 atoms | |\u2500\u2500 molecules | |\u2500\u2500 organisms | |\u2500\u2500 templates | \u2514\u2500\u2500 pages \u2514\u2500\u2500 templatetags a templates/patterns directory with subfolders for the different levels of pattern, following standard atomic design naming conventions. Your PATTERN_LIBRARY_TEMPLATE_DIR setting should point to the library's root templates directory a templatetags directory for holding template tag overrides (see below) Defining fake context for templates \u00b6 To define fake context you need to create a yaml file alongside your template file. For example, for the template big_red_button.html you need to create a file called big_red_button.yaml . Let's imagine that your big_red_button.html template looks like this: <a href=\" {{ button_link }} \" class=\"button button--red\"> <span> {{ button_text }} </span> </a> The big_red_button.yaml can be something like this: context : button_link : https://example.com/ button_text : Example link In the same way you can provide context in more complex templates. Here is an example on how you can define fake context that pretends to be a QuerySet . Let's assume you have the following template: {% if my_objects.exists %} {{ items_title }} <ul> {% for obj in my_objects.all %} <li> <a href=\" {{ obj.link }} \"> {{ obj.title }} </a> </li> {% endfor %} </ul> {% endif %} You might define a yaml file similar to this to provide fake data: name : My example pattern context : items_title : Related pages my_objects : exists : true # simulate `QuerySet`'s `exists` method all : # simulate `QuerySet`'s `all` method - title : Page 1 link : /page1 - title : Page 2 link : /page2 You can define a list or a dict or anything that PyYAML allows you to create in yaml format without creating a custom objects. Customising the patterns\u2019 surroundings \u00b6 All patterns that are not pages are rendered within a base page template, pages/base.html by default. The pattern library will render patterns inside the content block, which you can tweak to change how patterns are displayed. You can for example add a theme wrapper around the components: {% block content %} {% if pattern_library_rendered_pattern %} < div class = \"pattern-library bg bg--light\" > {{ pattern_library_rendered_pattern }} </ div > {% endif %} {% endblock %} pattern_library_rendered_pattern can also be used to do other modifications on the page for the pattern library only, for example adding an extra class to <body> : < body class = \"{% block body_class %}{% endblock %}{% if pattern_library_rendered_pattern %} pattern-library-template{% endif %}\" > Override template tags \u00b6 The package overrides the following Django tags: {% extends %} {% include %} It's required to allow us to define fake template context and override other template tags in yaml files. This package uses custom behaviour for these tags only when rendering pattern library and falls back to Django's standard behaviour on all other cases. The override process has two parts: Override your template tag with a mock implementation Define fake result for your tag in a yaml file When do I need to override a template tag? \u00b6 Ideally your pattern library should be independent, so it doesn't fail when you run it with a project that has no entries in DB or on a local machine without internet connection. This means that you need to override a template tag when it hits DB or any other resource (cache, or requests URL, for example). Override modes \u00b6 There are two options when it comes to template tag overriding: Render another template or pattern (a template with own fake context) instead of calling the original template tag Return raw data. For example, you can return a string, that will be rendered instead of the original template tag. You can also return a structure (dict or list) which is useful when overriding \"Simple tags\" or a custom tag that returns an object or dict Output into a variable \u00b6 Some tags can set their value into a variable like: {# renders something #} {% my_tag some_arg %} {# Outputs into a variable for later use #} {% my_tag some_arg as result_var %} {{ result_var.some_attr }} The package automatically detects an output variable ( result_var in our example) when a custom template tag is a \"Simple tag\" , so you don't need to worry about these tags. But when you need to override a tag which sets result into a variable in it's custom django.template.Node you would need to specify output var name manually. We will look into how to do that later in the examples section. Overriding examples \u00b6 Let's assume that we want to override the {% image image resize_rule %} template tag from the some_package.image_utils template tag set (you have something like {% load image_utils %} at the top of your template). This template tag resizes an image accordingly to a specific resize_rule and outputs the <img> html tag. It's also possible to assign an image object into a variable using this syntax: {% image image resize_rule as my_var_name %} . In this case tag doesn't render the <img> tag, but you can access image object's properties ( my_var_name.url , for example). First, we need to override a template tag with fake implementation. Note that the fake implementation will only be used when viewing the pattern library: you will be using the actual implementation in our production code. Assuming that you already have module installed in your project, to define a fake implementation we need to: Create a templatetags package in one of your apps. Note that your app should be defined in INSTALLED_APPS and it should be defined after the package you are overriding ( some_package in our case). Create image_utils.py in this package with the following code: ```python from some_package.templatetags.image_utils import register from pattern_library.monkey_utils import override_tag We are monkey patching here \u00b6 Note that register should be an instance of django.template.Library \u00b6 and it's important to the instance where the original tag is defined. \u00b6 override_tag(register, name='image') ``` Note: it's recommended to have a single app that contains all template tag overrides, so it's easy to exclude it from INSTALLED_APPS in production, if you want to. Now we need to define fake result for each instance of our template tag. Let's assume that we have a template with two calls of the {% image $} template tag: ` {% load image_utils %} ` <div class=\"user\"> <div class=\"user-avatar\"> {% image avatar fill-200x200 %} </div> <div class=\"user-data\"> <div>Username: {{ username }} </div> <div> <div>User photo:</div> {% image avatar fill-200x400 %} </div> </div> </div> Render another template or pattern \u00b6 Our yaml will similar to this: # Override template tags tags : # Name of the template tag we are overriding image : # Arguments of the template tag # Override {% image avatar fill-200x200 %} avatar fill-200x200 : template_name : \"patterns/atoms/images/image.html\" # Override {% image avatar fill-200x400 %} avatar fill-200x400 : template_name : \"patterns/atoms/images/image.html\" # Override context, if needed In this example, we override both template tags and render the same template: patterns/atoms/images/image.html . This template is a regular Django template. If it's a pattern, like in our example, it will be rendered with its own fake content defined in patterns/atoms/images/image.yaml . The downside of this approach is that we render the same template where an image can be rendered in a different size. So, if patterns/atoms/images/image.html has something like <img src=\"http://via.placeholder.com/200x200\" width=\"200\" height=\"200\" alt=\"Placeholder\"> inside, this means that we will render image of size 200x200 few times. Probably, in the majority of cases, it's ok to render the same template, but not when we are rendering images of different sizes. There are two approaches for this problem: Create a template for every image size you need. It can be a template that you will be only using for pattern library: no production use. This is a good option, when you want define a fake result for a template tag that renders a big piece of HTML code. Also it's useful when the template tag renders some other pattern, which is a common situation. For tags that render something small like <img> tag, there is an alternative option: you can define raw data in your yaml file Return raw data \u00b6 Let's update our yaml to use raw data: # Override template tags tags : # Name of the template tag we are overriding image : # Arguments of the template tag # Override {% image avatar fill-200x200 %} avatar fill-200x200 : raw : > <img src=\"http://via.placeholder.com/200x200\" width=\"200\" height=\"200\" alt=\"Placeholder\"> # Override {% image avatar fill-200x400 %} avatar fill-200x400 : raw : > <img src=\"http://via.placeholder.com/200x400\" width=\"200\" height=\"400\" alt=\"Placeholder\"> # Override context, if needed Now we make both {% image %} tags return different strings without creating a separate templates for them. The raw field, can contain any data supported by PyYAML without creating a custom object type. For example, if we have a template like this: {% comment %} The following tag assigns result into avatar_thumbnail for later use and renders nothing (empty string). {% endcomment %} {% image avatar fill-200x200 as avatar_thumbnail %} Avatar file path: {{ avatar_thumbnail.file }} Avatar URL: {{ avatar_thumbnail.url }} Avatar: <img src=\" {{ avatar_thumbnail.url }} \" alt=\" {{ username }} \"> We can define our yaml like this: tags : image : # Override {% image avatar fill-200x200 as avatar_thumbnail %} avatar fill-200x200 as avatar_thumbnail : raw : file : \"/path/to/avatar/file\" url : \"http://via.placeholder.com/200x200\" Note that the example above will only work if our image is a \"Simple tag\" . If it's a more custom implementation, we will need to specify output variable name explicitly like this: tags : image : # Override {% image avatar fill-200x200 as avatar_thumbnail %} avatar fill-200x200 as avatar_thumbnail : target_var : avatar_thumbnail raw : file : \"/path/to/avatar/file\" url : \"http://via.placeholder.com/200x200\" Note the target_var field. Some more examples \u00b6 Looping over a template tag \u00b6 HTML \u00b6 {% social_media_links as social_links %} <ul class= \"footer__social-links\" > {% for link in social_links %} {# Only render if we have a link #} {% if link.url %} <li class= \"social-item social-item-- {{ link.type }} \" > <a class= \"social-item__link\" href= \" {{ link.url }} \" aria-label= \" {{ link.label }} \" > <svg class= \"social-item__icon\" width= \"24\" height= \"24\" > <use xlink:href= \"# {{ link.type }} \" > </use> </svg> </a> </li> {% endif %} {% endfor %} </ul> Yaml \u00b6 tags : social_media_links : as social_links : raw : - url : '#' type : twitter label : Twitter - url : '#' type : facebook label : Facebook - url : '#' type : instagram label : Instagram - url : '#' type : youtube label : YouTube - url : '#' type : linkedin label : LinkedIn Inclusion tags \u00b6 HTML \u00b6 <div class= \"footer__action\" > {% footernav %} </div> YAML \u00b6 tags : footernav : \"\" : template_name : \"patterns/molecules/navigation/footernav.html\" Image lazy load example \u00b6 HTML \u00b6 { % image slide . image fill - 100 x71 as imageSmall % } { % image slide . image fill - 829 x585 as imageLarge % } { % include \"patterns/atoms/image/image--lazyload.html\" with imageSmall = imageSmall width = 829 height = 585 imageLarge = imageLarge classList = 'slide__image' % } YAML \u00b6 tags : image : slide . image fill - 100 x71 as imageSmall : target_var : imageSmall raw : url : '//placekitten.com/100/71' slide . image fill - 829 x585 as imageLarge : target_var : imageLarge raw : url : '//placekitten.com/829/585' width : '829' height : '585' Image inlude example \u00b6 HTML \u00b6 < img src = \"{{ imageSmall.url }}\" data - src = \"{{ imageLarge.url }}\" width = \"{{ width }}\" height = \"{{ height }}\" alt = \"{{ imageLarge.alt }}\" class = \"{{ classList }} lazyload\" > YAML \u00b6 context : width : '829' height : '585' imageSmall : url : '//placekitten.com/100/71' imageLarge : url : '//placekitten.com/829/585'","title":"Overview"},{"location":"overview/#overview","text":"The main idea of this package is to allow you use template in both: your pattern library and production code of your Django project. To achieve this the package must to provide a way to: Define a fake context for templates Override template tags (default and custom ones)","title":"Overview"},{"location":"overview/#directory-structure","text":"The initial structure of your pattern library should look like this: . \u251c\u2500\u2500 templates | \u2514\u2500\u2500 patterns | |\u2500\u2500 atoms | |\u2500\u2500 molecules | |\u2500\u2500 organisms | |\u2500\u2500 templates | \u2514\u2500\u2500 pages \u2514\u2500\u2500 templatetags a templates/patterns directory with subfolders for the different levels of pattern, following standard atomic design naming conventions. Your PATTERN_LIBRARY_TEMPLATE_DIR setting should point to the library's root templates directory a templatetags directory for holding template tag overrides (see below)","title":"Directory structure"},{"location":"overview/#defining-fake-context-for-templates","text":"To define fake context you need to create a yaml file alongside your template file. For example, for the template big_red_button.html you need to create a file called big_red_button.yaml . Let's imagine that your big_red_button.html template looks like this: <a href=\" {{ button_link }} \" class=\"button button--red\"> <span> {{ button_text }} </span> </a> The big_red_button.yaml can be something like this: context : button_link : https://example.com/ button_text : Example link In the same way you can provide context in more complex templates. Here is an example on how you can define fake context that pretends to be a QuerySet . Let's assume you have the following template: {% if my_objects.exists %} {{ items_title }} <ul> {% for obj in my_objects.all %} <li> <a href=\" {{ obj.link }} \"> {{ obj.title }} </a> </li> {% endfor %} </ul> {% endif %} You might define a yaml file similar to this to provide fake data: name : My example pattern context : items_title : Related pages my_objects : exists : true # simulate `QuerySet`'s `exists` method all : # simulate `QuerySet`'s `all` method - title : Page 1 link : /page1 - title : Page 2 link : /page2 You can define a list or a dict or anything that PyYAML allows you to create in yaml format without creating a custom objects.","title":"Defining fake context for templates"},{"location":"overview/#customising-the-patterns-surroundings","text":"All patterns that are not pages are rendered within a base page template, pages/base.html by default. The pattern library will render patterns inside the content block, which you can tweak to change how patterns are displayed. You can for example add a theme wrapper around the components: {% block content %} {% if pattern_library_rendered_pattern %} < div class = \"pattern-library bg bg--light\" > {{ pattern_library_rendered_pattern }} </ div > {% endif %} {% endblock %} pattern_library_rendered_pattern can also be used to do other modifications on the page for the pattern library only, for example adding an extra class to <body> : < body class = \"{% block body_class %}{% endblock %}{% if pattern_library_rendered_pattern %} pattern-library-template{% endif %}\" >","title":"Customising the patterns\u2019 surroundings"},{"location":"overview/#override-template-tags","text":"The package overrides the following Django tags: {% extends %} {% include %} It's required to allow us to define fake template context and override other template tags in yaml files. This package uses custom behaviour for these tags only when rendering pattern library and falls back to Django's standard behaviour on all other cases. The override process has two parts: Override your template tag with a mock implementation Define fake result for your tag in a yaml file","title":"Override template tags"},{"location":"overview/#when-do-i-need-to-override-a-template-tag","text":"Ideally your pattern library should be independent, so it doesn't fail when you run it with a project that has no entries in DB or on a local machine without internet connection. This means that you need to override a template tag when it hits DB or any other resource (cache, or requests URL, for example).","title":"When do I need to override a template tag?"},{"location":"overview/#override-modes","text":"There are two options when it comes to template tag overriding: Render another template or pattern (a template with own fake context) instead of calling the original template tag Return raw data. For example, you can return a string, that will be rendered instead of the original template tag. You can also return a structure (dict or list) which is useful when overriding \"Simple tags\" or a custom tag that returns an object or dict","title":"Override modes"},{"location":"overview/#output-into-a-variable","text":"Some tags can set their value into a variable like: {# renders something #} {% my_tag some_arg %} {# Outputs into a variable for later use #} {% my_tag some_arg as result_var %} {{ result_var.some_attr }} The package automatically detects an output variable ( result_var in our example) when a custom template tag is a \"Simple tag\" , so you don't need to worry about these tags. But when you need to override a tag which sets result into a variable in it's custom django.template.Node you would need to specify output var name manually. We will look into how to do that later in the examples section.","title":"Output into a variable"},{"location":"overview/#overriding-examples","text":"Let's assume that we want to override the {% image image resize_rule %} template tag from the some_package.image_utils template tag set (you have something like {% load image_utils %} at the top of your template). This template tag resizes an image accordingly to a specific resize_rule and outputs the <img> html tag. It's also possible to assign an image object into a variable using this syntax: {% image image resize_rule as my_var_name %} . In this case tag doesn't render the <img> tag, but you can access image object's properties ( my_var_name.url , for example). First, we need to override a template tag with fake implementation. Note that the fake implementation will only be used when viewing the pattern library: you will be using the actual implementation in our production code. Assuming that you already have module installed in your project, to define a fake implementation we need to: Create a templatetags package in one of your apps. Note that your app should be defined in INSTALLED_APPS and it should be defined after the package you are overriding ( some_package in our case). Create image_utils.py in this package with the following code: ```python from some_package.templatetags.image_utils import register from pattern_library.monkey_utils import override_tag","title":"Overriding examples"},{"location":"overview/#we-are-monkey-patching-here","text":"","title":"We are monkey patching here"},{"location":"overview/#note-that-register-should-be-an-instance-of-djangotemplatelibrary","text":"","title":"Note that register should be an instance of django.template.Library"},{"location":"overview/#and-its-important-to-the-instance-where-the-original-tag-is-defined","text":"override_tag(register, name='image') ``` Note: it's recommended to have a single app that contains all template tag overrides, so it's easy to exclude it from INSTALLED_APPS in production, if you want to. Now we need to define fake result for each instance of our template tag. Let's assume that we have a template with two calls of the {% image $} template tag: ` {% load image_utils %} ` <div class=\"user\"> <div class=\"user-avatar\"> {% image avatar fill-200x200 %} </div> <div class=\"user-data\"> <div>Username: {{ username }} </div> <div> <div>User photo:</div> {% image avatar fill-200x400 %} </div> </div> </div>","title":"and it's important to the instance where the original tag is defined."},{"location":"overview/#render-another-template-or-pattern","text":"Our yaml will similar to this: # Override template tags tags : # Name of the template tag we are overriding image : # Arguments of the template tag # Override {% image avatar fill-200x200 %} avatar fill-200x200 : template_name : \"patterns/atoms/images/image.html\" # Override {% image avatar fill-200x400 %} avatar fill-200x400 : template_name : \"patterns/atoms/images/image.html\" # Override context, if needed In this example, we override both template tags and render the same template: patterns/atoms/images/image.html . This template is a regular Django template. If it's a pattern, like in our example, it will be rendered with its own fake content defined in patterns/atoms/images/image.yaml . The downside of this approach is that we render the same template where an image can be rendered in a different size. So, if patterns/atoms/images/image.html has something like <img src=\"http://via.placeholder.com/200x200\" width=\"200\" height=\"200\" alt=\"Placeholder\"> inside, this means that we will render image of size 200x200 few times. Probably, in the majority of cases, it's ok to render the same template, but not when we are rendering images of different sizes. There are two approaches for this problem: Create a template for every image size you need. It can be a template that you will be only using for pattern library: no production use. This is a good option, when you want define a fake result for a template tag that renders a big piece of HTML code. Also it's useful when the template tag renders some other pattern, which is a common situation. For tags that render something small like <img> tag, there is an alternative option: you can define raw data in your yaml file","title":"Render another template or pattern"},{"location":"overview/#return-raw-data","text":"Let's update our yaml to use raw data: # Override template tags tags : # Name of the template tag we are overriding image : # Arguments of the template tag # Override {% image avatar fill-200x200 %} avatar fill-200x200 : raw : > <img src=\"http://via.placeholder.com/200x200\" width=\"200\" height=\"200\" alt=\"Placeholder\"> # Override {% image avatar fill-200x400 %} avatar fill-200x400 : raw : > <img src=\"http://via.placeholder.com/200x400\" width=\"200\" height=\"400\" alt=\"Placeholder\"> # Override context, if needed Now we make both {% image %} tags return different strings without creating a separate templates for them. The raw field, can contain any data supported by PyYAML without creating a custom object type. For example, if we have a template like this: {% comment %} The following tag assigns result into avatar_thumbnail for later use and renders nothing (empty string). {% endcomment %} {% image avatar fill-200x200 as avatar_thumbnail %} Avatar file path: {{ avatar_thumbnail.file }} Avatar URL: {{ avatar_thumbnail.url }} Avatar: <img src=\" {{ avatar_thumbnail.url }} \" alt=\" {{ username }} \"> We can define our yaml like this: tags : image : # Override {% image avatar fill-200x200 as avatar_thumbnail %} avatar fill-200x200 as avatar_thumbnail : raw : file : \"/path/to/avatar/file\" url : \"http://via.placeholder.com/200x200\" Note that the example above will only work if our image is a \"Simple tag\" . If it's a more custom implementation, we will need to specify output variable name explicitly like this: tags : image : # Override {% image avatar fill-200x200 as avatar_thumbnail %} avatar fill-200x200 as avatar_thumbnail : target_var : avatar_thumbnail raw : file : \"/path/to/avatar/file\" url : \"http://via.placeholder.com/200x200\" Note the target_var field.","title":"Return raw data"},{"location":"overview/#some-more-examples","text":"","title":"Some more examples"},{"location":"overview/#looping-over-a-template-tag","text":"","title":"Looping over a template tag"},{"location":"overview/#html","text":"{% social_media_links as social_links %} <ul class= \"footer__social-links\" > {% for link in social_links %} {# Only render if we have a link #} {% if link.url %} <li class= \"social-item social-item-- {{ link.type }} \" > <a class= \"social-item__link\" href= \" {{ link.url }} \" aria-label= \" {{ link.label }} \" > <svg class= \"social-item__icon\" width= \"24\" height= \"24\" > <use xlink:href= \"# {{ link.type }} \" > </use> </svg> </a> </li> {% endif %} {% endfor %} </ul>","title":"HTML"},{"location":"overview/#yaml","text":"tags : social_media_links : as social_links : raw : - url : '#' type : twitter label : Twitter - url : '#' type : facebook label : Facebook - url : '#' type : instagram label : Instagram - url : '#' type : youtube label : YouTube - url : '#' type : linkedin label : LinkedIn","title":"Yaml"},{"location":"overview/#inclusion-tags","text":"","title":"Inclusion tags"},{"location":"overview/#html_1","text":"<div class= \"footer__action\" > {% footernav %} </div>","title":"HTML"},{"location":"overview/#yaml_1","text":"tags : footernav : \"\" : template_name : \"patterns/molecules/navigation/footernav.html\"","title":"YAML"},{"location":"overview/#image-lazy-load-example","text":"","title":"Image lazy load example"},{"location":"overview/#html_2","text":"{ % image slide . image fill - 100 x71 as imageSmall % } { % image slide . image fill - 829 x585 as imageLarge % } { % include \"patterns/atoms/image/image--lazyload.html\" with imageSmall = imageSmall width = 829 height = 585 imageLarge = imageLarge classList = 'slide__image' % }","title":"HTML"},{"location":"overview/#yaml_2","text":"tags : image : slide . image fill - 100 x71 as imageSmall : target_var : imageSmall raw : url : '//placekitten.com/100/71' slide . image fill - 829 x585 as imageLarge : target_var : imageLarge raw : url : '//placekitten.com/829/585' width : '829' height : '585'","title":"YAML"},{"location":"overview/#image-inlude-example","text":"","title":"Image inlude example"},{"location":"overview/#html_3","text":"< img src = \"{{ imageSmall.url }}\" data - src = \"{{ imageLarge.url }}\" width = \"{{ width }}\" height = \"{{ height }}\" alt = \"{{ imageLarge.alt }}\" class = \"{{ classList }} lazyload\" >","title":"HTML"},{"location":"overview/#yaml_3","text":"context : width : '829' height : '585' imageSmall : url : '//placekitten.com/100/71' imageLarge : url : '//placekitten.com/829/585'","title":"YAML"}]}